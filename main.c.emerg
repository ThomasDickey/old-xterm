#ifndef lint
static char rcs_id[] = "$XConsortium: main.c,v 1.70 88/08/18 21:45:43 jim Exp $";
#endif	/* lint */

/*
 * WARNING:  This code (particularly, the tty setup code) is a historical
 * relic and should not be confused with a real toolkit application or a
 * an example of how to do anything.  It really needs a rewrite.  Badly.
 */

#include <X11/copyright.h>

/***********************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/


/* main.c */

#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <pwd.h>

/*
 * The macII uses System V terminal control, but bsd for a lot of other things.
 * That is why it is doesn't use SYSV....
 */
#ifdef macII
#include <sys/ioctl.h>
#include <sys/termio.h>
#include <sys/stat.h>
#include <sys/ttychars.h>
#include <compat.h>

#define vhangup() ;
#define setpgrp2 setpgrp
#define USE_SYSV_TERMIO
#define USE_SYSV_UTMP
/* do not use System V signals since we change to 4.2bsd compatibility mode */
#endif /* macII */

#ifdef SYSV				/* note that macII is *not* SYSV */
#include <sys/ioctl.h>
#include <sys/termio.h>
# ifndef mips
# include <sys/ptyio.h>
# endif /* not mips */
#include <sys/stat.h>
# ifdef JOBCONTROL
# include <sys/bsdtty.h>
# endif	/* JOBCONTROL */
#define USE_SYSV_TERMIO
#define USE_SYSV_UTMP
#define USE_SYSV_SIGNALS
#else	/* else not SYSV */		/* BSD and macII */
#include <sgtty.h>
#include <sys/wait.h>
#include <sys/resource.h>
#endif	/* !SYSV */


#include <stdio.h>
#include <errno.h>
#include <signal.h>
#include <setjmp.h>

#ifdef hpux
#include <sys/utsname.h>
#endif /* hpux */

#ifdef apollo
#define ttyslot() 1
#define vhangup() ;
#endif /* apollo */

#include <utmp.h>
#include <sys/param.h>	/* for NOFILE */

#include "ptyx.h"
#include "data.h"
#include "error.h"
#include "main.h"
#include <X11/StringDefs.h>
#include <X11/Shell.h>

extern Pixmap make_gray();
extern char *malloc();
extern char *calloc();
extern char *realloc();
extern char *ttyname();
extern void exit();
extern void sleep();
extern void Bcopy();
extern void vhangup();
extern long lseek();

int switchfb[] = {0, 2, 1, 3};

static int reapchild ();

static Bool added_utmp_entry = False;

static char **command_to_exec;

#ifdef USE_SYSV_TERMIO
/* The following structures are initialized in main() in order
** to eliminate any assumptions about the internal order of their
** contents.
*/
static struct termio d_tio;
#ifdef TIOCSLTC
static struct ltchars d_ltc;
#endif	/* TIOCSLTC */
#ifdef TIOCLSET
static unsigned int d_lmode;
#endif	/* TIOCLSET */
#else /* not USE_SYSV_TERMIO */
static struct  sgttyb d_sg = {
        0, 0, 0177, CKILL, EVENP|ODDP|ECHO|XTABS|CRMOD
};
static struct  tchars d_tc = {
        CINTR, CQUIT, CSTART,
        CSTOP, CEOF, CBRK,
};
static struct  ltchars d_ltc = {
        CSUSP, CDSUSP, CRPRNT,
        CFLUSH, CWERASE, CLNEXT
};
static int d_disipline = NTTYDISC;
static long int d_lmode = LCRTBS|LCRTERA|LCRTKIL|LCTLECH;
#endif /* USE_SYSV_TERMIO */

#ifdef USE_SYSV_UTMP
extern struct utmp *getutent();
extern struct utmp *getutid();
extern struct utmp *getutline();
extern void pututline();
extern void setutent();
extern void endutent();
extern void utmpname();

extern struct passwd *getpwent();
extern struct passwd *getpwuid();
extern struct passwd *getpwnam();
extern void setpwent();
extern void endpwent();
extern struct passwd *fgetpwent();
#else	/* not USE_SYSV_UTMP */
static char etc_utmp[] = "/etc/utmp";
#endif	/* USE_SYSV_UTMP */

static char *get_ty;
static int inhibit;
static char passedPty[2];	/* name if pty if slave */
static int loginpty;

#ifdef TIOCCONS
static int Console;
#endif	/* TIOCCONS */
#ifndef USE_SYSV_UTMP
static int tslot;
#endif	/* USE_SYSV_UTMP */
static jmp_buf env;

char *ProgramName;
Boolean sunFunctionKeys;

static struct _resource {
    char *xterm_name;
    char *icon_geometry;
    char *title;
    char *icon_name;
    Boolean utmpInhibit;
    Boolean sunFunctionKeys;	/* %%% should be widget resource? */
} resource;

#ifndef GETTY_EXE
#define GETTY_EXE "/etc/getty"
#endif /* GETTY_EXE */

static char *getty_program = GETTY_EXE;

/* used by VT (charproc.c) */

#define offset(field)	XtOffset(struct _resource *, field)

static XtResource application_resources[] = {
    {"name", "Name", XtRString, sizeof(char *),
	offset(xterm_name), XtRString, "xterm"},
    {"iconGeometry", "IconGeometry", XtRString, sizeof(char *),
	offset(icon_geometry), XtRString, (caddr_t) NULL},
    {XtNtitle, XtCTitle, XtRString, sizeof(char *),
	offset(title), XtRString, (caddr_t) NULL},
    {XtNiconName, XtCIconName, XtRString, sizeof(char *),
	offset(icon_name), XtRString, (caddr_t) NULL},
    {"utmpInhibit", "UtmpInhibit", XtRBoolean, sizeof (Boolean),
	offset(utmpInhibit), XtRString, "false"},
    {"sunFunctionKeys", "SunFunctionKeys", XtRBoolean, sizeof (Boolean),
	offset(sunFunctionKeys), XtRString, "false"},
};
#undef offset

/* Command line options table.  Only resources are entered here...there is a
   pass over the remaining options after XtParseCommand is let loose. */

static XrmOptionDescRec optionDescList[] = {
{"-geometry",	"*vt100.geometry",XrmoptionSepArg,	(caddr_t) NULL},
{"-132",	"*c132",	XrmoptionNoArg,		(caddr_t) "on"},
{"+132",	"*c132",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "on"},
{"+ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "off"},
{"-b",		"*internalBorder",XrmoptionSepArg,	(caddr_t) NULL},
{"-cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "off"},
{"+cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "on"},
{"-cc",		"*charClass",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cr",		"*cursorColor",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "off"},
{"-e",		NULL,		XrmoptionSkipLine,	(caddr_t) NULL},
{"-fb",		"*boldFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "off"},
{"-l",		"*logging",	XrmoptionNoArg,		(caddr_t) "on"},
{"+l",		"*logging",	XrmoptionNoArg,		(caddr_t) "off"},
{"-lf",		"*logFile",	XrmoptionSepArg,	(caddr_t) NULL},
{"-ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mc",		"*multiClickTime", XrmoptionSepArg,	(caddr_t) NULL},
{"-ms",		"*pointerColor",XrmoptionSepArg,	(caddr_t) NULL},
{"-nb",		"*nMarginBell",	XrmoptionSepArg,	(caddr_t) NULL},
{"-rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "off"},
{"-s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "on"},
{"+sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "off"},
{"-si",		"*scrollInput",	XrmoptionNoArg,		(caddr_t) "off"},
{"+si",		"*scrollInput",	XrmoptionNoArg,		(caddr_t) "on"},
{"-sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sl",		"*saveLines",	XrmoptionSepArg,	(caddr_t) NULL},
{"-t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "on"},
{"+t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "off"},
{"-vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "off"},
/* bogus old compatibility stuff for which there are
   standard XtInitialize options now */
#ifndef TRASHEQUALGEOMETRY
{"=",		"*vt100.geometry",XrmoptionStickyArg,	(caddr_t) NULL},
#endif
{"%",		"*tekGeometry",	XrmoptionStickyArg,	(caddr_t) NULL},
{"#",		".iconGeometry",XrmoptionStickyArg,	(caddr_t) NULL},
{"-T",		"*title",	XrmoptionSepArg,	(caddr_t) NULL},
{"-n",		"*iconName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-w",		".TopLevelShell.borderWidth", XrmoptionSepArg, (caddr_t) NULL},
};

static char *options[] = {
"-display displayname        X server to contact",
"-geometry geom              size (in characters) and position",
"-/+rv                       turn on/off reverse video",
"-bg color                   background color",
"-fg color                   foreground color",
"-bd color                   border color",
"-bw number                  border width in pixels",
"-fn fontname                normal text font",
"-iconic                     start iconic",
"-name string                client instance, icon, and title strings",
"-title string               title string",
"-xrm resourcestring         additional resource specifications",
"-/+132                      turn on/off column switch inhibiting",
"-/+ah                       turn on/off always highlight",
"-b number                   internal border in pixels",
"-/+cb                       turn on/off cut-to-beginning-of-line inhibit",
"-cc classrange              specify additional character classes",
"-/+cn                       turn on/off cut newline inhibit",
"-cr color                   text cursor color",
"-/+cu                       turn on/off curses emulation",
"-fb fontname                bold text font",
"-/+j                        turn on/off jump scroll",
"-/+l                        turn on/off logging",
"-lf filename                logging filename",
"-/+ls                       turn on/off login shell",
"-/+mb                       turn on/off margin bell",
"-mc milliseconds            multiclick time in milliseconds",
"-ms color                   pointer color",
"-nb number                  margin bell in characters from right end",
"-/+rw                       turn on/off reverse wraparound",
"-/+s                        turn on/off multiscroll",
"-/+sb                       turn on/off scrollbar",
"-/+sf                       turn on/off Sun Function Key escape codes",
"-/+si                       turn on/off scroll-on-input inhibit",
"-/+sk                       turn on/off scroll-on-keypress",
"-sl number                  number of scrolled lines to save",
"-/+t                        turn on/off Tek emulation window",
"-/+ut                       turn on/off utmp inhibit",
"-/+vb                       turn on/off visual bell",
"-e command args             command to execute",
"%geom                       Tek window geometry",
"#geom                       icon window geometry",
"-T string                   title name for window",
"-n string                   icon name for window",
"-C                          console mode",
"-L                          getty mode started from init",
"-Sxxd                       slave mode on \"ttyxx\", file descriptor \"d\"",
NULL };

static char *message[] = {
"Fonts must be fixed width and, if both normal and bold are specified, must",
"have the same size.  If only a normal font is specified, it will be used for",
"both normal and bold text (by doing overstriking).  The -e option, if given,",
"must be appear at the end of the command line, otherwise the user's default",
"shell will be started.  Options that start with a plus sign (+) restore the",
"default.",
NULL};

Syntax (badOption)
    char *badOption;
{
    char **cpp;

    fprintf (stderr, "%s:  bad option \"%s\" given\n\n",
	     ProgramName, badOption);

    fprintf (stderr, "usage:\n        %s [-options ...] [-e command args]\n\n",
	     ProgramName);
    fprintf (stderr, "where options include:\n");
    for (cpp = options; *cpp; cpp++) {
	fprintf (stderr, "    %s\n", *cpp);
    }

    putc ('\n', stderr);
    for (cpp = message; *cpp; cpp++) {
	fputs (*cpp, stderr);
	putc ('\n', stderr);
    }
    putc ('\n', stderr);

    exit (1);
}


extern WidgetClass xtermWidgetClass;

Arg ourTopLevelShellArgs[] = {
	{ XtNallowShellResize, (XtArgVal) TRUE },	
	{ XtNinput, (XtArgVal) TRUE },
};
int number_ourTopLevelShellArgs = 2;
	
Widget toplevel;

main (argc, argv)
int argc;
char **argv;
{
	register TScreen *screen;
	register int i, pty;
	int Xsocket, mode;
	char *basename();
	int xerror(), xioerror();
	int fd1 = -1;
	int fd2 = -1;
	int fd3 = -1;

	ProgramName = argv[0];

#ifdef macII
	/*
	 * The following sets us to use BSD-style signals, process group, and
	 * tty handling.
	 */
	set42sig ();
#endif /* macII */

	ttydev = (char *) malloc (strlen (TTYDEV) + 1);
	ptydev = (char *) malloc (strlen (PTYDEV) + 1);
	if (!ttydev || !ptydev) {
	    fprintf (stderr, 
	    	     "%s:  unable to allocate memory for ttydev or ptydev\n",
		     ProgramName);
	    exit (1);
	}
	strcpy (ttydev, TTYDEV);
	strcpy (ptydev, PTYDEV);

#ifdef USE_SYSV_TERMIO
	/* Initialization is done here rather than above in order
	** to prevent any assumptions about the order of the contents
	** of the various terminal structures (which may change from
	** implementation to implementation.
	*/
#ifdef macII
	d_tio.c_iflag = ICRNL|IXON;
	d_tio.c_oflag = OPOST|ONLCR|TAB3;
    	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
    	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;

	d_tio.c_line = 0;

	d_tio.c_cc[VINTR] = CINTR;
	d_tio.c_cc[VQUIT] = CQUIT;
	d_tio.c_cc[VERASE] = CERASE;
	d_tio.c_cc[VKILL] = CKILL;
    	d_tio.c_cc[VEOF] = CEOF;
	d_tio.c_cc[VEOL] = CNUL;
	d_tio.c_cc[VEOL2] = CNUL;
	d_tio.c_cc[VSWTCH] = CNUL;

        d_ltc.t_suspc = CSUSP;		/* t_suspc */
        d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
        d_ltc.t_rprntc = 0;		/* reserved...*/
        d_ltc.t_flushc = 0;
        d_ltc.t_werasc = 0;
        d_ltc.t_lnextc = 0;
#else  /* macII */
	d_tio.c_iflag = ICRNL|IXON;
	d_tio.c_oflag = OPOST|ONLCR|TAB3;
#ifdef BAUD_0
    	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
#else	/* !BAUD_0 */
    	d_tio.c_cflag = B9600|CS8|CREAD|PARENB|HUPCL;
#endif	/* !BAUD_0 */
    	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
	d_tio.c_line = 0;
	d_tio.c_cc[VINTR] = 0x7f;		/* DEL  */
	d_tio.c_cc[VQUIT] = '\\' & 0x3f;	/* '^\'	*/
	d_tio.c_cc[VERASE] = '#';		/* '#'	*/
	d_tio.c_cc[VKILL] = '@';		/* '@'	*/
    	d_tio.c_cc[VEOF] = 'D' & 0x3f;		/* '^D'	*/
	d_tio.c_cc[VEOL] = '@' & 0x3f;		/* '^@'	*/
#ifdef VSWTCH
	d_tio.c_cc[VSWTCH] = '@' & 0x3f;	/* '^@'	*/
#endif	/* VSWTCH */
	/* now, try to inherit tty settings */
	{
	    int i;

	    for (i = 0; i <= 2; i++) {
		struct termio deftio;
		if (ioctl (i, TCGETA, &deftio) == 0) {
		    d_tio.c_cc[VINTR] = deftio.c_cc[VINTR];
		    d_tio.c_cc[VQUIT] = deftio.c_cc[VQUIT];
		    d_tio.c_cc[VERASE] = deftio.c_cc[VERASE];
		    d_tio.c_cc[VKILL] = deftio.c_cc[VKILL];
		    d_tio.c_cc[VEOF] = deftio.c_cc[VEOF];
		    d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
#ifdef VSWTCH
		    d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
#endif /* VSWTCH */
		    break;
		}
	    }
	}
#ifdef TIOCSLTC
        d_ltc.t_suspc = '\000';		/* t_suspc */
        d_ltc.t_dsuspc = '\000';	/* t_dsuspc */
        d_ltc.t_rprntc = '\377';	/* reserved...*/
        d_ltc.t_flushc = '\377';
        d_ltc.t_werasc = '\377';
        d_ltc.t_lnextc = '\377';
#endif	/* TIOCSLTC */
#ifdef TIOCLSET
	d_lmode = 0;
#endif	/* TIOCLSET */
#endif  /* macII */
#endif	/* USE_SYSV_TERMIO */

	/* This is ugly.  When running under init, we need to make sure
	 * Xlib/Xt won't use file descriptors 0/1/2, because we need to
	 * stomp on them.  This check doesn't guarantee a -L found is
	 * really an option, but the opens don't hurt anyway.
	 */
	for (i = 1; i < argc; i++) {
	    if ((argv[i][0] == '-') && (argv[i][1] == 'L')) {
		fd1 = open ("/dev/null", O_RDONLY, 0);
		fd2 = open ("/dev/null", O_RDONLY, 0);
		fd3 = open ("/dev/null", O_RDONLY, 0);
		break;
	    }
	}
	/* Init the Toolkit. */
	toplevel = XtInitialize("main", "XTerm",
		optionDescList, XtNumber(optionDescList), &argc, argv);

	XtGetApplicationResources( toplevel, &resource, application_resources,
				   XtNumber(application_resources), NULL, 0 );

	xterm_name = resource.xterm_name;
	sunFunctionKeys = resource.sunFunctionKeys;
	if (strcmp(xterm_name, "-") == 0) xterm_name = "xterm";
	if (resource.icon_geometry != NULL) {
	    int scr, junk;
	    Arg args[2];

	    for(scr = 0;	/* yyuucchh */
		XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel),scr);
		scr++);

	    args[0].name = XtNiconX;
	    args[1].name = XtNiconY;
	    XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		      0, 0, 0, 0, 0, &args[0].value, &args[1].value,
		      &junk, &junk);
	    XtSetValues( toplevel, args, 2);
	}

	XtSetValues (toplevel, ourTopLevelShellArgs, 
		     number_ourTopLevelShellArgs);

	/* Now that we are in control again, close any uglies. */
	if (fd1 >= 0)
	    (void)close(fd1);
	if (fd2 >= 0)
	    (void)close(fd2);
	if (fd3 >= 0)
	    (void)close(fd3);


	/* Parse the rest of the command line */
	for (argc--, argv++ ; argc > 0 ; argc--, argv++) {
	    if(**argv != '-') Syntax (*argv);

	    switch(argv[0][1]) {
#ifdef TIOCCONS
	     case 'C':
		Console = TRUE;
		continue;
#endif	/* TIOCCONS */
	     case 'L':
		{
		static char *t_ptydev = NULL;
		static char *t_ttydev = NULL;

		if (!t_ptydev) {
		    t_ptydev = malloc (strlen (PTYDEV) + 1);
		    t_ttydev = malloc (strlen (TTYDEV) + 1);
		    if (!t_ptydev || !t_ttydev) {
			fprintf (stderr, 
			 "%s:  unable to alloc memory for t_ttydev or t_ptydev\n",
				 ProgramName);
			exit (1);
		    }
		    strcpy (t_ptydev, PTYDEV);
		    strcpy (t_ttydev, TTYDEV);
		}

		L_flag = 1;
		get_ty = argv[--argc];
		t_ptydev[strlen(t_ptydev) - 2] =
			t_ttydev[strlen(t_ttydev) - 2] =
			get_ty[strlen(get_ty) - 2];
		t_ptydev[strlen(t_ptydev) - 1] =
			t_ttydev[strlen(t_ttydev) - 1] =
			get_ty[strlen(get_ty) - 1];
		loginpty = open( t_ptydev, O_RDWR, 0 );
#ifdef USE_SYSV_UTMP
		/* use the same tty name that everyone else will use
		** (from ttyname)
		*/
		{
			char *ptr;

			if (ptr = ttyname(loginpty)) {
				/* it may be bigger! */
				t_ptydev = realloc (t_ptydev,
						    (unsigned) (strlen(ptr) + 1));
				(void) strcpy(t_ptydev, ptr);
			}
		}
#endif /* USE_SYSV_UTMP */
		loginpty = open( t_ptydev, O_RDWR, 0 );
		dup2( loginpty, 4);
		close( loginpty );
		loginpty = 4;
		chown(t_ttydev, 0, 0);
		chmod(t_ttydev, 0622);
		if (open(t_ttydev, O_RDWR, 0) < 0) {
			consolepr("open(%s) failed\n", t_ttydev);
		}
		signal(SIGHUP, SIG_IGN);
#ifdef SYSV
#ifdef JOBCONTROL
		{
			/* kind of do a vhangup */
			int tty_pgrp;

			if (!ioctl(0, TIOCGPGRP, &tty_pgrp)) {
				(void) kill (-tty_pgrp, SIGHUP);
			}
		}
		setpgrp2(0,0);
#else	/* !JOBCONTROL */
		setpgrp();
#endif	/* !JOBCONTROL */
#else	/* !SYSV */
		vhangup();
		setpgrp(0,0);
#endif	/* !SYSV */
		signal(SIGHUP, SIG_DFL);
		(void) close(0);
		open(t_ttydev, O_RDWR, 0);
		dup2(0, 1);
		dup2(0, 2);
		continue;
		}
	     case 'S':
		sscanf(*argv + 2, "%c%c%d", passedPty, passedPty+1,
		 &am_slave);
		if (am_slave <= 0) Syntax(*argv);
		continue;
#ifdef DEBUG
	     case 'D':
		debug = TRUE;
		continue;
#endif	/* DEBUG */
	     case 'e':
		if (argc <= 1) Syntax (*argv);
		command_to_exec = ++argv;
		break;
	     default:
		Syntax (*argv);
	    }
	    break;
	}

        term = (XtermWidget) XtCreateManagedWidget(
	    "vt100", xtermWidgetClass, toplevel, NULL, 0);
            /* this causes the initialize method to be called */

        screen = &term->screen;

	term->flags = WRAPAROUND;
#ifdef DO_AUTOREPEAT
	/*
	 * This whole autorepeat crud is bogus as it is really global state,
	 * not per window state.  Use "xset r" instead.
	 */
	term->flags |= AUTOREPEAT;
#endif /* DO_AUTOREPEAT */
	if (!screen->jumpscroll)	term->flags |= SMOOTHSCROLL;
	if (term->misc.reverseWrap)		term->flags |= REVERSEWRAP;

	inhibit = 0;
	if (term->misc.logInhibit)			inhibit |= I_LOG;
	if (term->misc.signalInhibit)		inhibit |= I_SIGNAL;
	if (term->misc.tekInhibit)			inhibit |= I_TEK;

	term->initflags = term->flags;

/*
 * Set title and icon name if not specified
 */

	if (get_ty || command_to_exec) {
	    char window_title[1024];
	    Arg args[2];

	    if (!resource.title) {
		if (get_ty) {
#ifdef hpux
		    struct utsname name;    /* crock for hpux 8 char names */
		    uname(&name);
		    strcpy (window_title, "login(");
		    strcpy (window_title+6, name.nodename);
		    strcat (window_title, ")");
#else 
		    strcpy (window_title, "login(");
		    (void) gethostname(window_title+6, sizeof(window_title)-6);
		    strcat (window_title, ")");
#endif
		    resource.title = window_title;
		} else if (command_to_exec) {
		    resource.title = basename (command_to_exec[0]);
		} /* else not reached */
	    }

	    if (!resource.icon_name) 
	      resource.icon_name = resource.title;
	    XtSetArg (args[0], XtNtitle, resource.title);
	    XtSetArg (args[1], XtNiconName, resource.icon_name);		

	    XtSetValues (toplevel, args, 2);
	}


	if(inhibit & I_TEK)
		screen->TekEmu = FALSE;

	if(screen->TekEmu && !TekInit())
		exit(ERROR_INIT);

	/* set up stderr properly */
	i = -1;
#ifdef DEBUG
	if(debug)
		i = open ("xterm.debug.log", O_WRONLY | O_CREAT | O_TRUNC,
		 0666);
	else
#endif	/* DEBUG */
	if(get_ty)
		i = open("/dev/console", O_WRONLY, 0);
	if(i >= 0) {
#ifdef USE_SYSV_TERMIO
		/* SYSV has another pointer which should be part of the
		** FILE structure but is actually a seperate array.
		*/
		unsigned char *old_bufend;

		old_bufend = (unsigned char *) _bufend(stderr);
		fileno(stderr) = i;
		(unsigned char *) _bufend(stderr) = old_bufend;
#else /* else not USE_SYSV_TERMIO */
		fileno(stderr) = i;
#endif	/* USE_SYSV_TERMIO */
	}
	if(fileno(stderr) != (NOFILE - 1)) {
#ifdef USE_SYSV_TERMIO
		/* SYSV has another pointer which should be part of the
		** FILE structure but is actually a seperate array.
		*/
		unsigned char *old_bufend;

		dup2(fileno(stderr), (NOFILE - 1));
		old_bufend = (unsigned char *) _bufend(stderr);
		if(fileno(stderr) >= 3)
			close(fileno(stderr));
		fileno(stderr) = (NOFILE - 1);
		(unsigned char *) _bufend(stderr) = old_bufend;
#else	/* else not USE_SYSV_TERMIO */
		dup2(fileno(stderr), (NOFILE - 1));
		if(fileno(stderr) >= 3)
			close(fileno(stderr));
		fileno(stderr) = (NOFILE - 1);
#endif	/* USE_SYSV_TERMIO */
	}

	signal (SIGCHLD, reapchild);

	/* open a terminal for client */
	get_terminal ();
	spawn ();
	/* Realize procs have now been executed */

	Xsocket = screen->display->fd;
	pty = screen->respond;

	if (am_slave) { /* Write window id so master end can read and use */
	    char buf[80];

	    buf[0] = '\0';
	    sprintf (buf, "%lx\n", 
	    	     screen->TekEmu ? XtWindow (XtParent (tekWidget)) :
				      XtWindow (XtParent (term)));
	    write (pty, buf, strlen (buf));
	}

	if (term->misc.log_on) {
		StartLog(screen);
	}
	screen->inhibit = inhibit;

#ifdef USE_SYSV_TERMIO
	if (0 > (mode = fcntl(pty, F_GETFL, 0)))
		Error();
	mode |= O_NDELAY;
	if (fcntl(pty, F_SETFL, mode))
		Error();
#else	/* USE_SYSV_TERMIO */
	mode = 1;
	if (ioctl (pty, FIONBIO, (char *)&mode) == -1) SysError (ERROR_FIONBIO);
#endif	/* USE_SYSV_TERMIO */
	
	pty_mask = 1 << pty;
	X_mask = 1 << Xsocket;
	Select_mask = pty_mask | X_mask;
	max_plus1 = (pty < Xsocket) ? (1 + Xsocket) : (1 + pty);

#ifdef DEBUG
	if (debug) printf ("debugging on\n");
#endif	/* DEBUG */
	XSetErrorHandler(xerror);
	XSetIOErrorHandler(xioerror);
	for( ; ; )
		if(screen->TekEmu) {
			TekRun();
		} else
			VTRun();
}

char *basename(name)
char *name;
{
	register char *cp;
	char *rindex();

	return((cp = rindex(name, '/')) ? cp + 1 : name);
}

get_pty (pty, tty)
/*
   opens a pty, storing fildes in pty and tty.
 */
int *pty, *tty;
{
	int devindex, letter = 0;

#if defined (mips) && defined (SYSTYPE_SYSV)
	struct stat fstat_buf;

	*pty = open ("/dev/ptc", O_RDWR);
	if (*pty < 0 || (fstat (*pty, &fstat_buf)) < 0) {
	  fprintf (stderr, "%s: Out of ptys.\n", xterm_name);
	  exit (ERROR_PTYS);
	}
	sprintf (ttydev, "/dev/ttyq%d", minor(fstat_buf.st_rdev));
	sprintf (ptydev, "/dev/ptyq%d", minor(fstat_buf.st_rdev));
	if ((*tty = open (ttydev, O_RDWR)) < 0) {
	  fprintf (stderr, "%s: Unable to open tty.\n", xterm_name);
	  close (*pty);
	  exit (ERROR_PTYS);
	}
	return;
#else /* not (mips && SYSTYPE_SYSV) */
	while (letter < 11) {
	    ttydev [strlen(ttydev) - 2]  = ptydev [strlen(ptydev) - 2] =
		    PTYCHAR1 [letter++];
	    devindex = 0;

	    while (devindex < 16) {
		ttydev [strlen(ttydev) - 1] = ptydev [strlen(ptydev) - 1] =
			PTYCHAR2 [devindex++];
		if ((*pty = open (ptydev, O_RDWR)) < 0)
			continue;
		if ((*tty = open (ttydev, O_RDWR)) < 0) {
			close(*pty);
			continue;
		}
		return;
	    }
	}
	fprintf (stderr, "%s: Not enough available pty's\n", xterm_name);
	exit (ERROR_PTYS);
#endif /* mips && SYSTYPE_SYSV */
}

get_terminal ()
/* 
 * sets up X and initializes the terminal structure except for term.buf.fildes.
 */
{
	register TScreen *screen = &term->screen;
	
	screen->graybordertile = make_gray(term->core.border_pixel,
		term->core.background_pixel,
		DefaultDepth(screen->display, DefaultScreen(screen->display)));


	{
	    unsigned long fg, bg;

	    fg = screen->mousecolor;
	    bg = (screen->mousecolor == term->core.background_pixel) ?
		screen->foreground : term->core.background_pixel;

	    screen->arrow = make_arrow (fg, bg);
	}
}

/*
 * The only difference in /etc/termcap between 4014 and 4015 is that 
 * the latter has support for switching character sets.  We support the
 * 4015 protocol, but ignore the character switches.  Therefore, we should
 * probably choose 4014 over 4015.
 */

static char *tekterm[] = {
	"tek4014",
	"tek4015",		/* has alternate character set switching */
	"tek4013",
	"tek4010",
	"dumb",
	0
};

static char *vtterm[] = {
	"xterm",
	"vt102",
	"vt100",
	"ansi",
	"dumb",
	0
};

hungtty()
{
	longjmp(env, 1);
}

spawn ()
/* 
 *  Inits pty and tty and forks a login process.
 *  Does not close fd Xsocket.
 *  If getty,  execs getty rather than csh and uses std fd's rather
 *  than opening a pty/tty pair.
 *  If slave, the pty named in passedPty is already open for use
 */
{
	register TScreen *screen = &term->screen;
	int Xsocket = screen->display->fd;
	int index1, tty = -1;
	int discipline;
#ifdef USE_SYSV_TERMIO
	struct termio tio;
	struct termio dummy_tio;
#ifdef TIOCLSET
	unsigned lmode;
#endif	/* TIOCLSET */
#ifdef TIOCSLTC
	struct ltchars ltc;
#endif	/* TIOCSLTC */
	int one = 1;
	int zero = 0;
	int status;
#else	/* else not USE_SYSV_TERMIO */
	unsigned lmode;
	struct tchars tc;
	struct ltchars ltc;
	struct sgttyb sg;
#endif	/* USE_SYSV_TERMIO */

	char termcap [1024];
	char newtc [1024];
	char *ptr, *shname, *shname_minus;
	int i, no_dev_tty = FALSE;
#ifdef USE_SYSV_TERMIO
	char *dev_tty_name = (char *) 0;
	int fd;			/* for /etc/wtmp */
#endif	/* USE_SYSV_TERMIO */
	char **envnew;		/* new environment */
	char buf[32];
	char *TermName = NULL;
	int ldisc = 0;
#ifdef sun
#ifdef TIOCSSIZE
	struct ttysize ts;
#endif	/* TIOCSSIZE */
#else	/* not sun */
#ifdef TIOCSWINSZ
	struct winsize ws;
#endif	/* TIOCSWINSZ */
#endif	/* sun */
	struct passwd *pw = NULL;
#ifdef UTMP
	struct utmp utmp;
#endif	/* UTMP */
	extern int Exit();
	char *getenv();
	char *strindex ();

	screen->uid = getuid();
	screen->gid = getgid();

#if !defined(SYSV) || defined(JOBCONTROL)  /* a reason why macII isn't SYSV */
	/* so that TIOCSWINSZ || TIOCSIZE doesn't block */
	signal(SIGTTOU,SIG_IGN);
#endif	/* !defined(SYSV) || defined(JOBCONTROL) */

	if (get_ty) {
		screen->respond = loginpty;
#ifndef USE_SYSV_UTMP
		if((tslot = ttyslot()) <= 0)
			SysError(ERROR_TSLOT);
#ifdef TIOCCONS
		if (Console) {
			int on = 1;
			if (ioctl (0, TIOCCONS, (char *)&on) == -1)
				SysError(ERROR_TIOCCONS);
		}
#endif  /* TIOCCONS */
#endif	/* not USE_SYSV_UTMP */
	} else if (am_slave) {
		screen->respond = am_slave;
		ptydev[strlen(ptydev) - 2] = ttydev[strlen(ttydev) - 2] =
			passedPty[0];
		ptydev[strlen(ptydev) - 1] = ttydev[strlen(ttydev) - 1] =
			passedPty[1];

		/* use the same tty name that everyone else will use
		** (from ttyname)
		*/
		if (ptr = ttyname(ttydev)) {
			/* it may be bigger! */
			ttydev = realloc(ttydev, (unsigned) (strlen(ptr) + 1));
			(void) strcpy(ttydev, ptr);
		}
#ifndef USE_SYSV_UTMP
		if((tslot = ttyslot()) <= 0)
			SysError(ERROR_TSLOT2);
#endif	/* not USE_SYSV_UTMP */
		setgid (screen->gid);
		setuid (screen->uid);
	} else {
 		/*
 		 * Sometimes /dev/tty hangs on open (as in the case of a pty
 		 * that has gone away).  Simply make up some reasonable
 		 * defaults.
 		 */
 		signal(SIGALRM, hungtty);
 		alarm(2);		/* alarm(1) might return too soon */
 		if (! setjmp(env)) {
 			tty = open ("/dev/tty", O_RDWR, 0);
 			alarm(0);
 		} else {
 			tty = -1;
 			errno = ENXIO;
 		}
 		signal(SIGALRM, SIG_DFL);
 
 		if (tty < 0) {
			if (errno != ENXIO) SysError(ERROR_OPDEVTTY);
			else {
				no_dev_tty = TRUE;
#ifdef USE_SYSV_TERMIO
				tio = d_tio;
#ifdef TIOCSLTC
				ltc = d_ltc;
#endif	/* TIOCSLTC */
#ifdef TIOCLSET
				lmode = d_lmode;
#endif	/* TIOCLSET */
#else	/* not USE_SYSV_TERMIO */
				sg = d_sg;
				tc = d_tc;
				discipline = d_disipline;
				ltc = d_ltc;
				lmode = d_lmode;
#endif	/* USE_SYSV_TERMIO */
			}
		} else {
			/* get a copy of the current terminal's state */

#ifdef USE_SYSV_TERMIO
			if(ioctl(tty, TCGETA, &tio) == -1)
				SysError(ERROR_TIOCGETP);
#ifdef TIOCSLTC
			if(ioctl(tty, TIOCGLTC, &ltc) == -1)
				SysError(ERROR_TIOCGLTC);
#endif	/* TIOCSLTC */
#ifdef TIOCLSET
			if(ioctl(tty, TIOCLGET, &lmode) == -1)
				SysError(ERROR_TIOCLGET);
#endif	/* TIOCLSET */
#else	/* not USE_SYSV_TERMIO */
			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
				SysError (ERROR_TIOCGETP);
			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
				SysError (ERROR_TIOCGETC);
			if(ioctl(tty, TIOCGETD, (char *)&discipline) == -1)
				SysError (ERROR_TIOCGETD);
			if(ioctl(tty, TIOCGLTC, (char *)&ltc) == -1)
				SysError (ERROR_TIOCGLTC);
			if(ioctl(tty, TIOCLGET, (char *)&lmode) == -1)
				SysError (ERROR_TIOCLGET);
#endif	/* USE_SYSV_TERMIO */
			close (tty);

			/* close all std file descriptors */
			for (index1 = 0; index1 < 3; index1++)
				close (index1);
#ifndef SYSV				/* macII does want this! */
			if ((tty = open ("/dev/tty", O_RDWR, 0)) < 0)
				SysError (ERROR_OPDEVTTY2);

			if (ioctl (tty, TIOCNOTTY, (char *) NULL) == -1)
				SysError (ERROR_NOTTY);
			close (tty);
#endif	/* !SYSV */
		}

		get_pty (&screen->respond, &tty);

		/* use the same tty name that everyone else will use
		** (from ttyname)
		*/
		if (ptr = ttyname(tty)) {
			/* it may be bigger */
			ttydev = realloc (ttydev, (unsigned) (strlen(ptr) + 1));
			(void) strcpy(ttydev, ptr);
		}
		if (screen->respond < 3) {
			int newrespond = dupHigh (screen->respond);
			close (screen->respond);
			screen->respond = newrespond;
		}

		/* change ownership of tty to real group and user id */
		chown (ttydev, screen->uid, screen->gid);

		/* change protection of tty */
		chmod (ttydev, 0622);

		if (tty < 3) {
			int newtty = dupHigh (tty);
			close (tty);
			tty = newtty;
		}

		/* set the new terminal's state to be the old one's 
		   with minor modifications for efficiency */

#ifdef USE_SYSV_TERMIO
#ifdef mips
		/* If the control tty had its modes screwed around with,
		   eg. by lineedit in the shell, or emacs, etc. then tio
		   will have bad values.  Let's just get termio from the
		   new tty and tailor it.  */
		if (ioctl (tty, TCGETA, &tio) == -1)
		    SysError (ERROR_TIOCGETP);
		tio.c_lflag |= ECHOE;
#endif /* mips */

		/* input: nl->nl, don't ignore cr, cr->nl */
		tio.c_iflag &= ~(INLCR|IGNCR);
		tio.c_iflag |= ICRNL;
		/* ouput: cr->cr, nl is not return, no delays, ln->cr/nl */
		tio.c_oflag &=
		 ~(OCRNL|ONLRET|NLDLY|CRDLY|TABDLY|BSDLY|VTDLY|FFDLY);
		tio.c_oflag |= ONLCR;
#ifdef BAUD_0
		/* baud rate is 0 (don't care) */
		tio.c_cflag &= ~(CBAUD);
#else	/* !BAUD_0 */
		/* baud rate is 9600 (nice default) */
		tio.c_cflag &= ~(CBAUD);
		tio.c_cflag |= B9600;
#endif	/* !BAUD_0 */
		/* enable signals, canonical processing (erase, kill, etc),
		** echo
		*/
		tio.c_lflag |= ISIG|ICANON|ECHO;
		/* reset EOL to defalult value */
		tio.c_cc[VEOL] = '@' & 0x3f;		/* '^@'	*/
		/* certain shells (ksh & csh) change EOF as well */
		tio.c_cc[VEOF] = 'D' & 0x3f;		/* '^D'	*/
		if (ioctl (tty, TCSETA, &tio) == -1)
			SysError (ERROR_TIOCSETP);
#ifdef TIOCSLTC
		if (ioctl (tty, TIOCSLTC, &ltc) == -1)
			SysError (ERROR_TIOCSETC);
#endif	/* TIOCSLTC */
#ifdef TIOCLSET
		if (ioctl (tty, TIOCLSET, (char *)&lmode) == -1)
			SysError (ERROR_TIOCLSET);
#endif	/* TIOCLSET */
#else	/* not USE_SYSV_TERMIO */
		sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW);
		sg.sg_flags |= ECHO | CRMOD;
		/* make sure speed is set on pty so that editors work right*/
		sg.sg_ispeed = B9600;
		sg.sg_ospeed = B9600;
		/* reset t_brkc to default value */
		tc.t_brkc = -1;

		if (ioctl (tty, TIOCSETP, (char *)&sg) == -1)
			SysError (ERROR_TIOCSETP);
		if (ioctl (tty, TIOCSETC, (char *)&tc) == -1)
			SysError (ERROR_TIOCSETC);
		if (ioctl (tty, TIOCSETD, (char *)&discipline) == -1)
			SysError (ERROR_TIOCSETD);
		if (ioctl (tty, TIOCSLTC, (char *)&ltc) == -1)
			SysError (ERROR_TIOCSLTC);
		if (ioctl (tty, TIOCLSET, (char *)&lmode) == -1)
			SysError (ERROR_TIOCLSET);
#ifdef TIOCCONS
		if (Console) {
			int on = 1;
			if (ioctl (tty, TIOCCONS, (char *)&on) == -1)
				SysError(ERROR_TIOCCONS);
		}
#endif	/* TIOCCONS */
#endif	/* USE_SYSV_TERMIO */

		close (open ("/dev/null", O_RDWR, 0));

		for (index1 = 0; index1 < 3; index1++)
			dup2 (tty, index1);
#ifndef USE_SYSV_UTMP
		if((tslot = ttyslot()) <= 0)
			SysError(ERROR_TSLOT3);
#endif	/* not USE_SYSV_UTMP */

#ifdef UTMP
#ifdef USE_SYSV_UTMP
		/* If we have gotten this far, we can only assume that
		** we have (will have) set the utmp entry.  Anyway,
		** we won't reset it later if the pid's don't match.
		** Also, if utmpInhibit is set, then pretend failure.
		*/
		added_utmp_entry = resource.utmpInhibit ? False : True;
#else	/* not USE_SYSV_UTMP, it is bsd */
		added_utmp_entry = False;
		if (!resource.utmpInhibit &&
		    (pw = getpwuid(screen->uid)) &&
		    (i = open(etc_utmp, O_WRONLY)) >= 0) {
			bzero((char *)&utmp, sizeof(struct utmp));
			(void) strcpy(utmp.ut_line, ttydev + strlen("/dev/"));
			(void) strcpy(utmp.ut_name, pw->pw_name);
			(void) strcpy(utmp.ut_host, 
				      XDisplayString (screen->display));
			time(&utmp.ut_time);
			lseek(i, (long)(tslot * sizeof(struct utmp)), 0);
			write(i, (char *)&utmp, sizeof(struct utmp));
			added_utmp_entry = True;
			close(i);
		} else
			tslot = -tslot;
#endif	/* USE_SYSV_UTMP */
#endif	/* UTMP */
	}

        /* Realize the Tek or VT widget, depending on which mode we're in.
           If VT mode, this calls VTRealize (the widget's Realize proc) */
        XtRealizeWidget (screen->TekEmu ? XtParent(tekWidget) :
			 XtParent(term));

	if(screen->TekEmu) {
		envnew = tekterm;
		ptr = newtc;
	} else {
		envnew = vtterm;
		ptr = termcap;
	}
	while (*envnew != NULL) {
		if(tgetent(ptr, *envnew) == 1) {
			TermName = *envnew;
			if(!screen->TekEmu)
			    resize(screen, TermName, termcap, newtc);
			break;
		}
		envnew++;
	}
	if (TermName == NULL) {
	    fprintf (stderr, "%s:  unable to find usable termcap entry.\n",
		     ProgramName);
	    Exit (1);
	}

#ifdef sun
#ifdef TIOCSSIZE
	/* tell tty how big window is */
	if(screen->TekEmu) {
		ts.ts_lines = 38;
		ts.ts_cols = 81;
	} else {
		ts.ts_lines = screen->max_row + 1;
		ts.ts_cols = screen->max_col + 1;
	}
	ioctl  (screen->respond, TIOCSSIZE, &ts);
#endif	/* TIOCSSIZE */
#else	/* not sun */
#ifdef TIOCSWINSZ
	/* tell tty how big window is */
	if(screen->TekEmu) {
		ws.ws_row = 38;
		ws.ws_col = 81;
		ws.ws_xpixel = TFullWidth(screen);
		ws.ws_ypixel = TFullHeight(screen);
	} else {
		ws.ws_row = screen->max_row + 1;
		ws.ws_col = screen->max_col + 1;
		ws.ws_xpixel = FullWidth(screen);
		ws.ws_ypixel = FullHeight(screen);
	}
	ioctl (screen->respond, TIOCSWINSZ, (char *)&ws);
#endif	/* TIOCSWINSZ */
#endif	/* sun */
            
	if (!am_slave) {
#if defined(macII) || defined(USE_SYSV_SIGNALS)
	    (void) setpgrp (0, getpid());
	    (void) close (open (ttydev, O_RDWR, 0));
#endif /* macII or USE_SYSV_SIGNALS */
	    if ((screen->pid = fork ()) == -1)
		SysError (ERROR_FORK);
		
	    if (screen->pid == 0) {
		/*
		 * now in child process
		 */
		extern char **environ;
		int pgrp = getpid();
#ifdef USE_SYSV_TERMIO
		char numbuf[12];
#endif	/* USE_SYSV_TERMIO */

		close (Xsocket);
		close (screen->respond);
		if(fileno(stderr) >= 3)
			close (fileno(stderr));

		if (tty >= 0) close (tty);

		signal (SIGCHLD, SIG_DFL);
		signal (SIGHUP, SIG_IGN);
		/* restore various signals to their defaults */
		signal (SIGINT, SIG_DFL);
		signal (SIGQUIT, SIG_DFL);
		signal (SIGTERM, SIG_DFL);

		/* copy the environment before Setenving */
		for (i = 0 ; environ [i] != NULL ; i++) ;
		/*
		 * The `4' (`5' for SYSV) is the number of Setenv()
		 * calls which may add a new entry to the environment.
		 * The `1' is for the NULL terminating entry.
		 */
#ifdef SYSV				/* macII doesn't do COLUMNS/LINES */
		envnew = (char **) calloc ((unsigned) i + (5 + 1), sizeof(char *));
#else /* not SYSV */
		envnew = (char **) calloc ((unsigned) i + (4 + 1), sizeof(char *));
#endif /* SYSV */
		Bcopy((char *)environ, (char *)envnew, i * sizeof(char *));
		environ = envnew;
		Setenv ("TERM=", TermName);
		if(!TermName)
			*newtc = 0;
#ifdef SYSV				/* macII does not want this */
		sprintf (numbuf, "%d", screen->max_col + 1);
		Setenv("COLUMNS=", numbuf);
		sprintf (numbuf, "%d", screen->max_row + 1);
		Setenv("LINES=", numbuf);
#else /* not SYSV (including macII) */
		if (term->misc.titeInhibit) {
		    remove_termcap_entry (newtc, ":ti=");
		    remove_termcap_entry (newtc, ":te=");
		}
		Setenv ("TERMCAP=", newtc);
#endif	/* SYSV */

		sprintf (buf, "%lu", screen->TekEmu ? 
			 ((unsigned long) XtWindow (XtParent(tekWidget))) :
			 ((unsigned long) XtWindow (XtParent(term))));
		Setenv ("WINDOWID=", buf);
		/* put the display into the environment of the shell*/
		Setenv ("DISPLAY=", XDisplayString (screen->display));

		signal(SIGTERM, SIG_DFL);
#if defined(USE_SYSV_SIGNALS) && !defined(JOBCONTROL)
		close(open(ttyname(0), O_WRONLY, 0));
#else /* else not USE_SYSV_SIGNALS or is JOBCONTROL */		/* macII yes */
		ioctl(0, TIOCSPGRP, (char *)&pgrp);
		setpgrp (0, 0);
		close(open(ttyname(0), O_WRONLY, 0));
		setpgrp (0, pgrp);
#endif /* USE_SYSV_SIGNALS and not JOBCONTROL */

#ifdef USE_SYSV_UTMP
		/* Set up our utmp entry now.  We need to do it here
		** for the following reasons:
		**   - It needs to have our correct process id (for
		**     login).
		**   - If our parent was to set it after the fork(),
		**     it might make it out before we need it.
		**   - We need to do it before we go and change our
		**     user and group id's.
		*/

		(void) setutent ();
		/* set up entry to search for */
		(void) strncpy(utmp.ut_id,ttydev + strlen(ttydev) - 2,
		 sizeof (utmp.ut_id));
		utmp.ut_type = DEAD_PROCESS;

		/* position to entry in utmp file */
		(void) getutid(&utmp);

		/* set up the new entry */
		if (get_ty) {
		    utmp.ut_type = LOGIN_PROCESS;
		    utmp.ut_exit.e_exit = 0;
		    (void) strncpy(utmp.ut_user, "GETTY",
		    	    sizeof(utmp.ut_user));
		} else {
		    pw = getpwuid(screen->uid);
		    utmp.ut_type = USER_PROCESS;
		    utmp.ut_exit.e_exit = 2;
		    (void) strncpy(utmp.ut_user,
			    (pw && pw->pw_name) ? pw->pw_name : "????",
			    sizeof(utmp.ut_user));
		}
		    
		(void) strncmp(utmp.ut_id, ttydev + strlen(ttydev) - 2,
			sizeof(utmp.ut_id));
		(void) strncpy (utmp.ut_line,
			ttydev + strlen("/dev/"), sizeof (utmp.ut_line));
		utmp.ut_pid = getpid();
		utmp.ut_time = time ((long *) 0);

#ifdef UTMP
		/* write out the entry */
		if (!resource.utmpInhibit) (void) pututline(&utmp);
#endif	/* UTMP */

		/* close the file */
		(void) endutent();

		if (get_ty && !resource.utmpInhibit) {
		    /* set wtmp entry if wtmp file exists */
		    if (fd = open("/etc/wtmp", O_WRONLY | O_APPEND)) {
			(void) write(fd, &utmp, sizeof(utmp));
			(void) close(fd);
		    }
		}
#endif	/* USE_SYSV_UTMP */

		setgid (screen->gid);
		setuid (screen->uid);

		if (command_to_exec) {
			execvp(*command_to_exec, command_to_exec);
			/* print error message on screen */
			fprintf(stderr, "%s: Can't execvp %s\n", xterm_name,
			 *command_to_exec);
		}
		signal(SIGHUP, SIG_IGN);
		if (get_ty) {
#ifdef TIOCCONS
		    if (Console) {
			int on = 1;
			if (ioctl (1, TIOCCONS, (char *)&on) == -1)
			    SysError (ERROR_TIOCCONS);
		    }
#endif /* TIOCCONS */

#ifdef SYSV				/* macII does NOT want this */
#ifndef mips
			ioctl (0, TIOCTTY, &zero);
#endif /* not mips */
			execlp (getty_program, "getty", get_ty, "Xwindow", 0);

#else	/* !SYSV */
			ioctl (0, TIOCNOTTY, (char *) NULL);
			execlp (getty_program, "+", "Xwindow", get_ty, 0);
#endif	/* !SYSV */
		}
		signal(SIGHUP, SIG_DFL);

#ifdef UTMP
		if(((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		 ((pw == NULL && (pw = getpwuid(screen->uid)) == NULL) ||
		 *(ptr = pw->pw_shell) == 0))
#else	/* UTMP */
		if(((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		 ((pw = getpwuid(screen->uid)) == NULL ||
		 *(ptr = pw->pw_shell) == 0))
#endif	/* UTMP */
			ptr = "/bin/sh";
		if(shname = rindex(ptr, '/'))
			shname++;
		else
			shname = ptr;
		shname_minus = malloc(strlen(shname) + 2);
		(void) strcpy(shname_minus, "-");
		(void) strcat(shname_minus, shname);
#ifndef USE_SYSV_TERMIO
		ldisc = XStrCmp("csh", shname + strlen(shname) - 3) == 0 ?
		 NTTYDISC : 0;
		ioctl(0, TIOCSETD, (char *)&ldisc);
#endif	/* !USE_SYSV_TERMIO */
		execlp (ptr, term->misc.login_shell ? shname_minus : shname, 0);
		fprintf (stderr, "%s: Could not exec %s!\n", xterm_name, ptr);
		sleep(5);
		exit(ERROR_EXEC);
	    }
	}

	/*
	 * still in parent (xterm process)
	 */

	if(tty >= 0) close (tty);
#ifdef USE_SYSV_TERMIO
	/* the parent should not be associated with tty anymore */
	for (index1 = 0; index1 < 3; index1++)
		close(index1);
#endif	/* USE_SYSV_TERMIO */
	signal(SIGHUP,SIG_IGN);

	if (!no_dev_tty) {
		if ((tty = open ("/dev/tty", O_RDWR, 0)) < 0)
			SysError(ERROR_OPDEVTTY3);
		for (index1 = 0; index1 < 3; index1++)
			dup2 (tty, index1);
		if (tty > 2) close (tty);
	}

/*
 * Unfortunately, System V seems to have trouble divorcing the child process
 * from the process group of xterm.  This is a problem because hitting the 
 * INTR or QUIT characters on the keyboard will cause xterm to go away if we
 * don't ignore the signals.  This is annoying.
 */

#if defined(USE_SYSV_SIGNALS) && !defined(JOBCONTROL)
	signal (SIGINT, SIG_IGN);
	signal (SIGQUIT, SIG_IGN);
	signal (SIGTERM, SIG_IGN);
#else /* else is bsd or has job control */
	signal (SIGINT, Exit);
	signal (SIGQUIT, Exit);
	signal (SIGTERM, Exit);
#endif /* USE_SYSV_SIGNALS and not JOBCONTROL */

	return;
}							/* end spawn */

Exit(n)
int n;
{
	register TScreen *screen = &term->screen;
        int pty = term->screen.respond;  /* file descriptor of pty */
#ifdef UTMP
#ifdef USE_SYSV_UTMP
	struct utmp utmp;
	struct utmp *utptr;

	/* cleanup the utmp entry we forged earlier */
	if (!resource.utmpInhibit && added_utmp_entry) {
	    utmp.ut_type = USER_PROCESS;
	    (void) strncpy(utmp.ut_id, ttydev + strlen(ttydev) - 2,
		    sizeof(utmp.ut_id));
	    (void) setutent();
	    utptr = getutid(&utmp);
	    /* write it out only if it exists, and the pid's match */
	    if (utptr && (utptr->ut_pid = screen->pid)) {
		    utptr->ut_type = DEAD_PROCESS;
		    utptr->ut_time = time((long *) 0);
		    (void) pututline(utptr);
	    }
	    (void) endutent();
	}
#else	/* not USE_SYSV_UTMP */
	register int i;
	struct utmp utmp;

	if (!resource.utmpInhibit && added_utmp_entry &&
	    (!am_slave && tslot > 0 && (i = open(etc_utmp, O_WRONLY)) >= 0)) {
		bzero((char *)&utmp, sizeof(struct utmp));
		lseek(i, (long)(tslot * sizeof(struct utmp)), 0);
		write(i, (char *)&utmp, sizeof(struct utmp));
		close(i);
	}
#endif	/* USE_SYSV_UTMP */
#endif	/* UTMP */
        close(pty); /* close explicitly to avoid race with slave side */
	if(screen->logging)
		CloseLog(screen);

	if(!get_ty && !am_slave) {
		/* restore ownership of tty */
		chown (ttydev, 0, 0);

		/* restore modes of tty */
		chmod (ttydev, 0666);
	}
	exit(n);
}

resize(screen, TermName, oldtc, newtc)
TScreen *screen;
char *TermName;
register char *oldtc, *newtc;
{
	register char *ptr1, *ptr2;
	register int i;
	register int li_first = 0;
	register char *temp;
	char *index(), *strindex();

#ifndef SYSV				/* macII *does* want this */
	if ((ptr1 = strindex (oldtc, "co#")) == NULL){
		fprintf(stderr, "%s: Can't find co# in termcap string %s\n",
			xterm_name, TermName);
		exit (ERROR_NOCO);
	}
	if ((ptr2 = strindex (oldtc, "li#")) == NULL){
		fprintf(stderr, "%s: Can't find li# in termcap string %s\n",
			xterm_name, TermName);
		exit (ERROR_NOLI);
	}
	if(ptr1 > ptr2) {
		li_first++;
		temp = ptr1;
		ptr1 = ptr2;
		ptr2 = temp;
	}
	ptr1 += 3;
	ptr2 += 3;
	strncpy (newtc, oldtc, i = ptr1 - oldtc);
	newtc += i;
	sprintf (newtc, "%d", li_first ? screen->max_row + 1 :
	 screen->max_col + 1);
	newtc += strlen(newtc);
	ptr1 = index (ptr1, ':');
	strncpy (newtc, ptr1, i = ptr2 - ptr1);
	newtc += i;
	sprintf (newtc, "%d", li_first ? screen->max_col + 1 :
	 screen->max_row + 1);
	ptr2 = index (ptr2, ':');
	strcat (newtc, ptr2);
#endif	/* !SYSV */
}

static reapchild ()
{
#if defined(USE_SYSV_SIGNALS) && !defined(JOBCONTROL)
	int status, pid;

	pid = wait(&status);
	if (pid == -1) {
		(void) signal(SIGCHLD, reapchild);
		return;
	}
#else	/* defined(USE_SYSV_SIGNALS) && !defined(JOBCONTROL) */
	union wait status;
	register int pid;
	
#ifdef DEBUG
	if (debug) fputs ("Exiting\n", stderr);
#endif	/* DEBUG */
	pid  = wait3 (&status, WNOHANG, (struct rusage *)NULL);
	if (!pid) {
#ifdef USE_SYSV_SIGNALS
		(void) signal(SIGCHLD, reapchild);
#endif /* USE_SYSV_SIGNALS */
		return;
	}
#endif	/* defined(USE_SYSV_SIGNALS) && !defined(JOBCONTROL) */


	if (pid != term->screen.pid) {
#ifdef USE_SYSV_SIGNALS
		(void) signal(SIGCHLD, reapchild);
#endif	/* USE_SYSV_SIGNALS */
		return;
	}
	
	Cleanup(0);
}

/* VARARGS1 */
consolepr(fmt,x0,x1,x2,x3,x4,x5,x6,x7,x8,x9)
char *fmt;
{
	extern int errno;
	extern char *SysErrorMsg();
	int oerrno;
	int f;
 	char buf[ BUFSIZ ];

	oerrno = errno;
 	strcpy(buf, "xterm: ");
 	sprintf(buf+strlen(buf), fmt, x0,x1,x2,x3,x4,x5,x6,x7,x8,x9);
 	strcat(buf, ": ");
 	strcat(buf, SysErrorMsg (oerrno));
 	strcat(buf, "\n");	
	f = open("/dev/console",O_WRONLY);
	write(f, buf, strlen(buf));
	close(f);
#ifdef TIOCNOTTY
	if ((f = open("/dev/tty", 2)) >= 0) {
		ioctl(f, TIOCNOTTY, (char *)NULL);
		close(f);
	}
#endif	/* TIOCNOTTY */
}

int dupHigh(oldfd)
{
    int desc[3],i,j;
    /* Find an fd > 2 */
    for (i=0;i<3;i++) {
	desc[i] = dup(oldfd);
	if (desc[i] > 2)
	    break;
	}
    if (i==3) {
	fprintf(stderr,"dupHigh failed\n");
	exit(1);
	}
    /* Close unneeded ones */
    for (j=0;j<i;j++)
	close(desc[j]);
    return  desc[i];
}

checklogin() 
{
	register int ts, i;
	register struct passwd *pw;
#ifdef USE_SYSV_UTMP
	char *name;
#else /* not USE_SYSV_UTMP */
	struct utmp utmp;
#endif /* USE_SYSV_UTMP */

#ifdef USE_SYSV_UTMP
	name = cuserid((char *) 0);
	if (name)
		pw = getpwnam(name);
	else
		pw = getpwuid(getuid());
	if (pw == NULL)
		return(FALSE);
#else	/* not USE_SYSV_UTMP */
	ts = tslot > 0 ? tslot : -tslot;
	if((i = open(etc_utmp, O_RDONLY)) < 0)
		return(FALSE);
	lseek(i, (long)(ts * sizeof(struct utmp)), 0);
	ts = read(i, (char *)&utmp, sizeof(utmp));
	close(i);
	if(ts != sizeof(utmp) || XStrCmp(get_ty, utmp.ut_line) != 0 ||
	 !*utmp.ut_name || (pw = getpwnam(utmp.ut_name)) == NULL)
		return(FALSE);
	chdir(pw->pw_dir);
#endif	/* USE_SYSV_UTMP */
	setgid(pw->pw_gid);
	setuid(pw->pw_uid);
	L_flag = 0;
	return(TRUE);
}


remove_termcap_entry (buf, str)
    char *buf;
    char *str;
{
    register char *strinbuf;

    strinbuf = strindex (buf, str);
    if (strinbuf) {
        register char *colonPtr = index (strinbuf+1, ':');
        if (colonPtr) {
            register char *cp;

            while (*colonPtr) {
                *strinbuf++ = *colonPtr++;      /* copy down */
            }
            *strinbuf = '\0';
        } else {
            strinbuf[1] = '\0';
        }
    }
    return;
}


